!function(t,i){"object"==typeof exports&&"undefined"!=typeof module?module.exports=i():"function"==typeof define&&define.amd?define(i):(t="undefined"!=typeof globalThis?globalThis:t||self).WebSDK=i()}(this,function(){"use strict";const t="/auth/nonce",i="/mapp/events",e="/v2/visitors/config",s="/v2/visitors",n=6e4,a={CATEGORIES:{USER:"USER",BEHAVIORAL:"BE"},STATUSES:{PENDING:"pending"},BATCH_SIZE:50,MAX_RETRY_ATTEMPTS:5,DEFAULT_RETRY_DELAYS:[6e4,12e4,24e4,48e4,9e5],RETRYABLE_HTTP_CODES:[408,429,500,502,503,504,401],GLOBAL_SUCCESS_CODE:200,PARTIAL_SUCCESS_CODE:201},r={NONCE_DATA:"websdk_nonce_data",USER_CONTEXT:"websdk_user_context",SESSION_ID:"websdk_session_id",VISITOR_ID:"websdk_visitor_id",VISITOR_CONFIG:"websdk_visitor_config"},o=r;function h(t,i,e){const s=r[t],n=[];return i&&n.push(i),e&&n.push(e),n.length>0?`${n.join("_")}_${s}`:s}const c="websdk_storage_test",d="test_value",u="INIT_ERROR",l="AUTH_ERROR",w="NETWORK_ERROR",g="EVENT_ERROR",y="VISITOR_CONFIG_ERROR",f="WebSDK initialized successfully",v="Failed to initialize WebSDK",m="WebSDK destroyed successfully",I="Authentication successful",E="Authentication failed",p="AuthManager initialized successfully",S="Nonce request successful",D="Nonce request failed",b="Request signature generated successfully",_="Failed to store nonce data",x="Failed to restore nonce data from storage",C="Failed to clear stored nonce data",k="EventTracker initialized successfully",N="EventTracker destroyed successfully",A="Failed to track event",T="Events sent successfully",O="Failed to send events",R="Failed to initialize storage:",U="Storage test failed:",V="Storage read/write test failed",M="StorageManager destroyed successfully",F="Error during storage cleanup:",z="Failed to track user signin event",P="Failed to track user signup event",$="Failed to track user update event",B="Failed to track user signout event",q="Failed to track behavioral event",W="VisitorConfigManager initialized successfully",L="Visitor config fetched successfully",G="Failed to fetch visitor config",H="Visitor tracking is disabled",K="Visitor tracking is enabled",Q="Visitor config retrieved from cache",X="AnonymousVisitorManager initialized successfully",j="Visitor ID generated successfully",J="Failed to generate visitor ID",Y="Visitor ID restored from storage",Z="Using cached visitor ID",tt="web",it="",et="",st="",nt="user_signin",at="user_signup",rt="user_update",ot="user_signout",ht={WEBPUSH:"WEBPUSH"},ct={ACCOUNT_NOT_EXISTS:2432,ACCOUNT_ID_NOT_PASSED:9999},dt="1.0.2";class ut{constructor(t){this.baseUrl=t.baseUrl.replace(/\/$/,"")}async request(t,i={}){const{method:e="GET",headers:s={},body:n}=i,a=!t||t.startsWith("/")?t:`/${t}`;let r=this.baseUrl;"/v2/visitors"===t&&(r="https://crm-nightly-new.cc.capillarytech.com");const o=`${r}${a}`;try{const t={method:e,headers:{"Content-Type":"application/json",...s},body:n?JSON.stringify(n):null},i=await fetch(o,t);if(!i.ok){const t=await i.text();throw new Error(`HTTP ${i.status}: ${i.statusText} - ${t}`)}return await i.json()}catch(t){throw this.handleError(t)}}handleError(t){return t instanceof Error?"AbortError"===t.name?{code:w,message:"Request timeout",details:t}:t.message.includes("HTTP 401")||t.message.includes("HTTP 403")?{code:l,message:"Authentication failed",details:t}:(t.message.includes("HTTP"),{code:w,message:t.message,details:t}):{code:w,message:`Unknown error: ${String(t)}`,details:t}}async get(t,i={}){return this.request(t,{...i,method:"GET"})}async post(t,i,e={}){return this.request(t,{...e,method:"POST",body:i})}async put(t,i,e={}){return this.request(t,{...e,method:"PUT",body:i})}async delete(t,i={}){return this.request(t,{...i,method:"DELETE"})}}function lt(){try{return Intl.DateTimeFormat().resolvedOptions().timeZone}catch{return"UTC"}}function wt(){return window.location.hostname||"localhost"}function gt(t){const i=function(){const t=navigator.userAgent;let i="Unknown",e="Unknown";if(t.includes("Chrome")){i="Chrome";const s=t.match(/Chrome\/([0-9.]+)/);e=s?.[1]??"Unknown"}else if(t.includes("Firefox")){i="Firefox";const s=t.match(/Firefox\/([0-9.]+)/);e=s?.[1]??"Unknown"}else if(t.includes("Safari")&&!t.includes("Chrome")){i="Safari";const s=t.match(/Version\/([0-9.]+)/);e=s?.[1]??"Unknown"}else if(t.includes("Edge")){i="Edge";const s=t.match(/Edge\/([0-9.]+)/);e=s?.[1]??"Unknown"}let s="Unknown",n="Unknown";if(t.includes("Windows"))s="Windows",t.includes("Windows NT 10.0")?n="10":t.includes("Windows NT 6.3")?n="8.1":t.includes("Windows NT 6.2")?n="8":t.includes("Windows NT 6.1")&&(n="7");else if(t.includes("Mac OS X")){s="macOS";const i=t.match(/Mac OS X ([0-9_]+)/);n=i?.[1]?.replace(/_/g,".")??"Unknown"}else if(t.includes("Linux"))s="Linux",n="Unknown";else if(t.includes("Android")){s="Android";const i=t.match(/Android ([0-9.]+)/);n=i?.[1]??"Unknown"}else if(t.includes("iPhone")||t.includes("iPad")){s="iOS";const i=t.match(/OS ([0-9_]+)/);n=i?.[1]?.replace(/_/g,".")??"Unknown"}return{browserName:i,browserVersion:e,osName:s,osVersion:n}}(),e={width:window.innerWidth||document.documentElement.clientWidth||0,height:window.innerHeight||document.documentElement.clientHeight||0};return{os_version:i.osVersion,country_code:t.country_code,os_name:i.osName,viewport_width:e.width,country:t.country,viewport_height:e.height,bundle_identifier:wt(),last_seen:(new Date).toISOString(),city:t.city,sdk_version:dt,platform:"web",browser_name:i.browserName,browser_version:i.browserVersion,browser_language:navigator.language||navigator.languages&&navigator.languages[0]||"en-US",timezone:lt()}}function yt(){return"undefined"!=typeof crypto&&crypto.randomUUID?crypto.randomUUID():"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,t=>{const i=16*Math.random()|0;return("x"===t?i:3&i|8).toString(16)})}function ft(){return`session_${yt()}`}async function vt(t,i,e){try{const s=function(t){const i=Object.keys(t).sort();return i.map(i=>`${i}=${t[i]}`).join("&")}({nonce:i,account_id:e,timestamp:Date.now(),payload:JSON.stringify(t,Object.keys(t).sort())}),n=await async function(t){const i=`${t}:cap-hydra-web-sdk`,e=(new TextEncoder).encode(i),s=await crypto.subtle.digest("SHA-256",e);return await crypto.subtle.importKey("raw",s,{name:"HMAC",hash:"SHA-256"},!1,["sign"])}(e);return await async function(t,i){const e=(new TextEncoder).encode(t),s=await crypto.subtle.sign("HMAC",i,e);return btoa(String.fromCharCode(...new Uint8Array(s)))}(s,n)}catch(t){throw new Error(`Signature generation failed: ${t instanceof Error?t.message:"Unknown error"}`)}}class mt{constructor(t,i,e){this.httpClient=new ut(t),this.logger=i,this.accountId=e}async getNonce(i){this.logger.info("Requesting nonce",{accountId:this.accountId,bundleIdentifier:i});const e={account_id:this.accountId,bundle_identifier:i,timestamp:Date.now(),os_name:tt};try{const i=await this.httpClient.post(t,e);return this.logger.info(S,{challengeId:i.challenge_id,expiresAt:i.expires_at}),i}catch(t){throw this.logger.error(D,t),t}}async sendEvents(t,e,s,n,a){this.logger.info("Sending events",{eventCount:t.length,cuid:e,challengeId:a});const r={system_data:gt(s),request_id:yt(),events:t,cuid:e};try{const e=await vt({...r,nonce:n,challenge_id:a},n,this.accountId);this.logger.info(b,{requestId:r.request_id,challengeId:a});const s={"X-Cap-Nonce":n,"X-Cap-Challenge-ID":a,"X-Cap-Signature":e},o=await this.httpClient.post(i,r,{headers:s});return this.logger.info(T,{requestId:r.request_id,eventCount:t.length,success:o.status.success}),o}catch(i){throw this.logger.error(O,{requestId:r.request_id,eventCount:t.length,error:i}),i}}async getVisitorConfig(t,i){this.logger.info("Fetching visitor config",{orgId:t,vapId:i});try{const i={Authorization:"Basic b25lLnRpbGwwMToyMDJjYjk2MmFjNTkwNzViOTY0YjA3MTUyZDIzNGI3MA==","X-CAP-API-AUTH-ORG-ID":t},s=await this.httpClient.get(e,{headers:i});return this.logger.info(L,{isEnabled:s.isVisitorTrackingEnabled,warningCount:s.warnings?.length||0}),s}catch(t){throw this.logger.error(G,t),t}}async createVisitor(t,i,e){this.logger.info("Creating anonymous visitor",{orgId:t,vapId:i,profileCount:e.profiles.length,hasExtendedFields:!!e.extendedFields});try{if(!e.profiles||0===e.profiles.length)throw new Error("At least one profile is required");const i={Authorization:"Basic b25lLnRpbGwwMToyMDJjYjk2MmFjNTkwNzViOTY0YjA3MTUyZDIzNGI3MA==","X-CAP-API-AUTH-ORG-ID":t},n=await this.httpClient.post(s,e,{headers:i});return this.logger.info(j,{visitorId:n.id,warningCount:n.warnings?.length||0}),n}catch(t){throw this.logger.error(J,{error:t,accountId:e.profiles[0]?.accountId}),t}}}class It{constructor(t="WebSDK",i=2,e="data"){this.db=null,this.dbName=t,this.version=i,this.storeName=e,this.eventsStoreName="events"}async openDB(){return this.db?this.db:new Promise((t,i)=>{const e=indexedDB.open(this.dbName,this.version);e.onerror=()=>i(e.error),e.onsuccess=()=>{this.db=e.result,t(this.db)},e.onupgradeneeded=t=>{const i=t.target.result;if(i.objectStoreNames.contains(this.storeName)||i.createObjectStore(this.storeName),!i.objectStoreNames.contains(this.eventsStoreName)){const t=i.createObjectStore(this.eventsStoreName,{keyPath:"id"});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("status","status",{unique:!1})}}})}async getItem(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.storeName],"readonly").objectStore(this.storeName).get(t);n.onerror=()=>s(n.error),n.onsuccess=()=>{const t=n.result;e(null==t?null:"string"==typeof t?t:"object"==typeof t?JSON.stringify(t):String(t))}})}async setItem(t,i){const e=await this.openDB();return new Promise((s,n)=>{const a=e.transaction([this.storeName],"readwrite").objectStore(this.storeName).put(i,t);a.onerror=()=>n(a.error),a.onsuccess=()=>s()})}async removeItem(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(t);n.onerror=()=>s(n.error),n.onsuccess=()=>e()})}async clear(){const t=await this.openDB();return new Promise((i,e)=>{const s=t.transaction([this.storeName],"readwrite").objectStore(this.storeName).clear();s.onerror=()=>e(s.error),s.onsuccess=()=>i()})}async close(){this.db&&(this.db.close(),this.db=null)}async addEvent(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.eventsStoreName],"readwrite").objectStore(this.eventsStoreName).add(t);n.onerror=()=>s(n.error),n.onsuccess=()=>e()})}async getOldestPendingEvents(t=50,i){const e=await this.openDB();return new Promise((s,n)=>{const a=e.transaction([this.eventsStoreName],"readonly").objectStore(this.eventsStoreName).index("timestamp").openCursor(),r=[];let o=0;a.onerror=()=>n(a.error),a.onsuccess=e=>{const n=e.target.result;if(n&&o<t){const t=n.value;"pending"===t.status&&t.accountId===i&&(r.push(t),o++),n.continue()}else s(r)}})}async updateEventStatus(t,i,e,s){const n=await this.openDB();return new Promise((a,r)=>{const o=n.transaction([this.eventsStoreName],"readwrite").objectStore(this.eventsStoreName),h=o.get(t);h.onerror=()=>r(h.error),h.onsuccess=()=>{const n=h.result;if(n){n.status=i,n.lastAttempt=Date.now(),e&&(n.error=e),void 0!==s&&(n.attempts=s);const t=o.put(n);t.onerror=()=>r(t.error),t.onsuccess=()=>a()}else r(new Error(`Event with id ${t} not found`))}})}async removeEvents(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.eventsStoreName],"readwrite").objectStore(this.eventsStoreName);let a=0;const r=t.length;0!==r?t.forEach(t=>{const i=n.delete(t);i.onerror=()=>s(i.error),i.onsuccess=()=>{a++,a===r&&e()}}):e()})}async recoverOrphanedEvents(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.eventsStoreName],"readwrite").objectStore(this.eventsStoreName).openCursor();let a=0;n.onerror=()=>s(n.error),n.onsuccess=i=>{const s=i.target.result;if(s){const i=s.value;if("processing"===i.status&&i.accountId===t){i.status="failed",i.lastAttempt=Date.now(),i.error="Recovered from orphaned processing state";s.update(i).onsuccess=()=>{a++}}s.continue()}else e(a)}})}async getPendingEventCount(t){const i=await this.openDB();return new Promise((e,s)=>{const n=i.transaction([this.eventsStoreName],"readonly").objectStore(this.eventsStoreName).openCursor();let a=0;n.onerror=()=>s(n.error),n.onsuccess=i=>{const s=i.target.result;if(s){const i=s.value;"pending"===i.status&&i.accountId===t&&a++,s.continue()}else e(a)}})}async getRetryableEvents(t=5,i){const e=await this.openDB();return new Promise((s,n)=>{const a=e.transaction([this.eventsStoreName],"readonly").objectStore(this.eventsStoreName).openCursor(),r=[];a.onerror=()=>n(a.error),a.onsuccess=e=>{const n=e.target.result;if(n){const e=n.value;"failed"===e.status&&e.attempts<=t&&e.accountId===i&&r.push(e),n.continue()}else s(r)}})}}class Et{constructor(t,i,e,s){if(this.systemDataArgs=null,this.currentAccountId=null,this.currentCuid=null,this.isProcessing=!1,this.processingPromise=null,this.BATCH_SIZE=a.BATCH_SIZE,this.authManager=t,this.logger=i,this.RETRY_DELAYS=s||a.DEFAULT_RETRY_DELAYS,e&&"getIndexedDBAdapter"in e){const t=e.getIndexedDBAdapter();t?(i.info("EventQueue: Reusing existing IndexedDB adapter from StorageManager"),this.storage=t):(i.warn("EventQueue: StorageManager has no IndexedDB adapter, creating new one"),this.storage=new It)}else e?(i.info("EventQueue: Using provided IndexedDBStorage"),this.storage=e):(i.warn("EventQueue: No storage provided, creating new IndexedDBStorage"),this.storage=new It)}async init(){this.logger.info("Initializing EventQueue"),await this.processQueueIfIdle(),this.logger.info("EventQueue initialized successfully")}async setUserContext(t,i,e){this.currentAccountId=t,this.currentCuid=e||null,this.systemDataArgs=i,this.logger.debug("EventQueue user context set",{accountId:t,cuid:e,systemDataArgs:i});const s=await this.storage.recoverOrphanedEvents(t);s>0&&this.logger.info(`Recovered ${s} orphaned processing events for account ${t}`)}getCurrentAccountId(){return this.currentAccountId}getCurrentCuid(){return this.currentCuid}async enqueue(t){try{if(!this.currentAccountId)throw new Error("Cannot enqueue event: No account context set");const i={id:yt(),event:t,accountId:this.currentAccountId,timestamp:(new Date).toISOString(),attempts:0,status:a.STATUSES.PENDING};await this.storage.addEvent(i),this.logger.debug("Event added to queue",{eventId:i.id,eventType:t.category,eventName:t.name}),await this.processQueueIfIdle()}catch(i){throw this.logger.error("Failed to enqueue event",{event:t,error:i}),i}}async processQueueIfIdle(){if(!this.isProcessing)return this.processingPromise||(this.processingPromise=this.processQueue()),this.processingPromise;this.logger.debug("Queue processing already in progress, skipping")}async processQueue(){if(!this.isProcessing){this.isProcessing=!0,this.logger.debug("Starting queue processing");try{for(;;){if(await this.checkAndPromoteRetryEvents(),!this.currentAccountId){this.logger.debug("No account context, skipping event processing");break}const t=await this.storage.getOldestPendingEvents(this.BATCH_SIZE,this.currentAccountId);if(0===t.length){this.logger.debug("No pending events to process");break}this.logger.info("Processing batch of events",{batchSize:t.length,eventIds:t.map(t=>t.id)}),await this.markEventsAsProcessing(t),await this.sendBatch(t);if(0===await this.storage.getPendingEventCount(this.currentAccountId)){this.logger.debug("No more pending events");break}}}catch(t){this.logger.error("Queue processing failed",t)}finally{this.isProcessing=!1,this.processingPromise=null,this.logger.debug("Queue processing completed")}}}async markEventsAsProcessing(t){for(const i of t)try{await this.storage.updateEventStatus(i.id,"processing")}catch(t){this.logger.warn("Failed to mark event as processing",{eventId:i.id,error:t})}}async sendBatch(t){try{if(!this.currentAccountId)throw new Error("Missing account context for batch sending");const i=await this.authManager.getNonceData(),e=this.authManager.getApiClient(),s=t.map(t=>t.event),n=await e.sendEvents(s,this.currentCuid||"",this.systemDataArgs||{country:it,city:et,country_code:st},i.nonce,i.challengeId);return await this.handleBatchResponse(t,n),!0}catch(i){const e=this.isRetryableHttpError(i);return this.logger.error("Failed to send batch",{batchSize:t.length,error:i,isRetryable:e}),e?await this.handleFailedBatch(t):await this.removeNonRetryableEvents(t),!1}}async removeSuccessfulEvents(t){const i=t.map(t=>t.id);try{await this.storage.removeEvents(i),this.logger.debug("Successfully removed events from storage",{count:i.length})}catch(t){this.logger.error("Failed to remove events from storage",{eventIds:i,error:t})}}async handleBatchResponse(t,i){const e=i.status.code;if(e===a.GLOBAL_SUCCESS_CODE)await this.removeSuccessfulEvents(t),this.logger.info("All events processed successfully",{count:t.length});else if(e===a.PARTIAL_SUCCESS_CODE)await this.handlePartialSuccess(t,i.events);else{a.RETRYABLE_HTTP_CODES.includes(parseInt(e))?(await this.handleFailedBatch(t),this.logger.warn("Batch failed with retryable error",{code:e,message:i.status.message})):(await this.removeNonRetryableEvents(t),this.logger.error("Batch failed with non-retryable error",{code:e,message:i.status.message}))}}async handlePartialSuccess(t,i){const e=new Map;i.forEach(t=>{e.set(t.event_id,t)});for(const i of t){const t=e.get(i.event.event_id);if(t)if(t.status.success)await this.storage.removeEvents([i.id]),this.logger.debug("Event processed successfully",{eventId:i.id});else{const e=parseInt(t.status.code);a.RETRYABLE_HTTP_CODES.includes(e)?(await this.markEventForRetry(i,t.status.message),this.logger.debug("Event marked for retry",{eventId:i.id,code:e,message:t.status.message})):(await this.storage.removeEvents([i.id]),this.logger.warn("Event permanently failed - removed",{eventId:i.id,code:e,message:t.status.message}))}else await this.markEventForRetry(i,"No response received")}}async markEventForRetry(t,i){const e=(t.attempts||0)+1;await this.storage.updateEventStatus(t.id,"failed",`Attempt ${e} failed: ${i}`,e);const s=Math.min(Math.max(e-1,0),this.RETRY_DELAYS.length-1),n=this.RETRY_DELAYS[s];this.logger.debug("Event marked for retry",{eventId:t.id,attempts:e,delay:n,isInfiniteRetry:e>this.RETRY_DELAYS.length})}async checkAndPromoteRetryEvents(){try{if(!this.currentAccountId)return void this.logger.debug("No account context, skipping retry check");const t=await this.storage.getRetryableEvents(Number.MAX_SAFE_INTEGER,this.currentAccountId);if(0===t.length)return;let i=0;for(const e of t){const t=Math.min(Math.max(e.attempts-1,0),this.RETRY_DELAYS.length-1),s=this.RETRY_DELAYS[t],n=Date.now()-(e.lastAttempt||0);n>=(s||0)&&(await this.storage.updateEventStatus(e.id,"pending"),i++,this.logger.debug("Failed event promoted to pending",{eventId:e.id,attempt:e.attempts+1,delay:s,timeSinceLastAttempt:n}))}i>0&&this.logger.debug(`Promoted ${i} failed events for retry`)}catch(t){this.logger.error("Failed to check retry events",t)}}isRetryableHttpError(t){if(t.code){const i=parseInt(t.code);return a.RETRYABLE_HTTP_CODES.includes(i)}return t.message?.includes("network")||t.message?.includes("timeout")||t.message?.includes("fetch")}async removeNonRetryableEvents(t){const i=t.map(t=>t.id);try{await this.storage.removeEvents(i),this.logger.warn("Non-retryable events removed permanently",{eventIds:i})}catch(t){this.logger.error("Failed to remove non-retryable events",{eventIds:i,error:t})}}async handleFailedBatch(t){for(const i of t)try{await this.markEventForRetry(i,"Batch failed")}catch(t){this.logger.error("Failed to mark event for retry",{eventId:i.id,error:t})}}async flush(){this.logger.info("Manual flush requested"),await this.processQueueIfIdle()}async destroy(){this.logger.info("Destroying EventQueue"),this.processingPromise&&await this.processingPromise,await this.storage.close(),this.logger.info("EventQueue destroyed")}async clear(){this.logger.warn("Clear method not implemented for IndexedDB queue")}}class pt{constructor(t,i,e,s){this.eventQueue=null,this.initialized=!1,this.visitorId=null,this.isVisitorTrackingEnabled=null,this.config=t,this.logger=s,this.authManager=i,this.storageManager=e}async init(){this.initialized?this.logger.warn("EventTracker already initialized"):(this.logger.info("Initializing EventTracker with IndexedDB queue"),this.eventQueue=new Et(this.authManager,this.logger,this.storageManager,this.config.retryDelays),await this.eventQueue.init(),this.initialized=!0,this.logger.info(k))}async setUserContext(t,i,e){if(!this.eventQueue)throw new Error("EventTracker not initialized");await this.eventQueue.setUserContext(t,i,e),this.logger.info("User context set",{accountId:t,systemDataArgs:i,cuid:e})}setVisitorTrackingState(t,i){this.visitorId=t,this.isVisitorTrackingEnabled=i,this.logger.debug("Visitor tracking state updated",{visitorId:t,isEnabled:i})}async track(t){if(!this.initialized||!this.eventQueue)throw new Error("EventTracker not initialized");if(!1===this.isVisitorTrackingEnabled)throw this.logger.warn("Event tracking is disabled - visitor tracking is not enabled"),new Error("Event tracking is disabled");this.logger.debug("Tracking event",{event:t});try{const i=this.convertToApiEvent(t);await this.eventQueue.enqueue(i)}catch(i){throw this.logger.error(A,{event:t,error:i}),new Error(`${g}: ${i}`)}}convertToApiEvent(t){const i="user"===t.type?a.CATEGORIES.USER:a.CATEGORIES.BEHAVIORAL,e={...t.data};if(!this.eventQueue)throw new Error("EventTracker not initialized");const s=this.eventQueue.getCurrentCuid();if(!s&&!this.visitorId)throw new Error("Cannot track event: User must be identified (cuid) or visitor tracking must be enabled (visitorId)");return function(t,i,e,s,n){const a={...e};return s&&(a.cuid=s),n&&(a.visitor_id=n),{category:t,attributes:a,name:i,created_at:(new Date).toISOString(),event_id:yt()}}(i,t.name||"custom",e,s||void 0,this.visitorId||void 0)}async flush(){this.initialized&&this.eventQueue?(this.logger.info("Manual flush requested"),await this.eventQueue.flush()):this.logger.warn("Cannot flush events - EventTracker not initialized")}async destroy(){this.logger.info("Destroying EventTracker"),this.eventQueue&&await this.eventQueue.destroy(),this.initialized=!1,this.logger.info(N)}}class St{constructor(t,i,e){this.initialized=!1,this.nonceData=null,this.config=t,this.logger=i,this.storageManager=e,this.apiClient=new mt({baseUrl:t.baseURL},i,t.accountId)}async init(){this.initialized?this.logger.warn("AuthManager already initialized"):(this.logger.info("Initializing AuthManager",{accountId:this.config.accountId}),this.initialized=!0,this.logger.info(p))}async requestNonce(){if(!this.initialized)throw new Error("AuthManager not initialized");this.logger.info("Requesting nonce for authentication");try{const t=wt(),i=await this.apiClient.getNonce(t);return this.nonceData={nonce:i.nonce,challengeId:i.challenge_id,expiresAt:i.expires_at},await this.storeNonceData(),this.logger.info(I,{challengeId:i.challenge_id,expiresAt:i.expires_at}),this.nonceData}catch(t){throw this.logger.error(E,t),t}}async ensureValidNonce(){if(!this.initialized)throw new Error("AuthManager not initialized");this.logger.info("Ensuring valid nonce");try{return await this.restoreNonceData(),this.nonceData&&!this.isNonceExpired(this.nonceData.expiresAt)?(this.logger.info("Using existing valid nonce"),this.nonceData):(this.logger.info("No valid nonce found, requesting fresh"),await this.requestNonce())}catch(t){throw this.logger.error("Failed to ensure valid nonce",t),t}}async getNonceData(){return await this.ensureValidNonce()}isNonceExpired(t){return Date.now()>=t-n}hasValidNonce(){return!!this.nonceData&&!this.isNonceExpired(this.nonceData.expiresAt)}getApiClient(){return this.apiClient}async storeNonceData(){if(this.nonceData)try{await this.storageManager.set(o.NONCE_DATA,JSON.stringify(this.nonceData))}catch(t){this.logger.warn(_,t)}}async restoreNonceData(){try{const t=await this.storageManager.get(o.NONCE_DATA);t&&(this.nonceData=JSON.parse(t),this.logger.info("Nonce data restored from storage"))}catch(t){this.logger.warn(x,t),this.nonceData=null}}async clearNonceData(){this.nonceData=null;try{await this.storageManager.remove(o.NONCE_DATA)}catch(t){this.logger.warn(C,t)}}async destroy(){this.logger.info("Destroying AuthManager"),await this.clearNonceData(),this.initialized=!1,this.logger.info("AuthManager destroyed successfully")}}class Dt{constructor(t,i,e){this.initialized=!1,this.logger=t,this.brandId=i,this.applicationId=e,this.adapter=new bt}async init(){if(this.initialized)this.logger.warn("StorageManager already initialized");else{this.logger.info("Initializing StorageManager");try{if(this.isIndexedDBSupported()){const t=["WebSDK"];this.brandId&&t.push(this.brandId),this.applicationId&&t.push(this.applicationId);const i=t.join("_"),e=new It(i);await this.testStorageAdapter(e),this.adapter=e,this.logger.info("StorageManager initialized with IndexedDB",{dbName:i,brandId:this.brandId,applicationId:this.applicationId})}else await this.testStorageAdapter(this.adapter),this.logger.info("StorageManager initialized with localStorage");this.initialized=!0}catch(t){throw this.logger.error(R,t),new Error(`Storage initialization failed: ${t}`)}}}isIndexedDBSupported(){return"undefined"!=typeof window&&"indexedDB"in window&&null!==indexedDB}async testStorageAdapter(t){const i=c,e=d;try{await t.setItem(i,e);if(await t.getItem(i)!==e)throw new Error(V);await t.removeItem(i)}catch(t){throw new Error(`${U} ${t}`)}}async get(t){if(!this.initialized)throw new Error("StorageManager not initialized");return this.adapter.getItem(t)}async set(t,i){if(!this.initialized)throw new Error("StorageManager not initialized");return this.adapter.setItem(t,i)}async remove(t){if(!this.initialized)throw new Error("StorageManager not initialized");return this.adapter.removeItem(t)}async clear(){if(!this.initialized)throw new Error("StorageManager not initialized");return this.adapter.clear()}getIndexedDBAdapter(){return this.adapter instanceof It?this.adapter:null}async destroy(){this.logger.info("Destroying StorageManager");try{this.adapter instanceof It&&await this.adapter.close(),this.initialized=!1,this.logger.info(M)}catch(t){this.logger.error(F,t),this.initialized=!1}}}class bt{async getItem(t){try{return localStorage.getItem(t)}catch(t){throw new Error(`LocalStorage getItem failed: ${t}`)}}async setItem(t,i){try{localStorage.setItem(t,i)}catch(t){if(t instanceof DOMException&&(22===t.code||1014===t.code||"QuotaExceededError"===t.name||"NS_ERROR_DOM_QUOTA_REACHED"===t.name))throw new Error("LocalStorage quota exceeded");throw new Error(`LocalStorage setItem failed: ${t}`)}}async removeItem(t){try{localStorage.removeItem(t)}catch(t){throw new Error(`LocalStorage removeItem failed: ${t}`)}}async clear(){try{localStorage.clear()}catch(t){throw new Error(`LocalStorage clear failed: ${t}`)}}}var _t;!function(t){t[t.VERBOSE=0]="VERBOSE",t[t.DEBUG=1]="DEBUG",t[t.INFO=2]="INFO",t[t.WARN=3]="WARN",t[t.ERROR=4]="ERROR",t[t.NONE=5]="NONE"}(_t||(_t={}));class xt{constructor(t=!1,i=_t.INFO){this.logs=[],this.maxLogs=1e3,this.enabled=t,this.level=i}formatMessage(t,i){return`[${(new Date).toISOString()}] [WebSDK:${_t[t]}] ${i}`}log(t,i,e){if(!this.enabled||t<this.level)return;const s={level:t,message:i,timestamp:Date.now(),data:e};this.logs.push(s),this.logs.length>this.maxLogs&&this.logs.shift();const n=this.formatMessage(t,i),a=e?[n,e]:[n];switch(t){case _t.VERBOSE:case _t.DEBUG:break;case _t.INFO:console.info(...a);break;case _t.WARN:console.warn(...a);break;case _t.ERROR:console.error(...a)}}verbose(t,i){this.log(_t.VERBOSE,t,i)}debug(t,i){this.log(_t.DEBUG,t,i)}info(t,i){this.log(_t.INFO,t,i)}warn(t,i){this.log(_t.WARN,t,i)}error(t,i){this.log(_t.ERROR,t,i)}setLevel(t){this.level=t}setEnabled(t){this.enabled=t}getLogs(){return[...this.logs]}clearLogs(){this.logs=[]}}class Ct{constructor(t,i,e,s,n,a,r){this.initialized=!1,this.cachedConfig=null,this.orgId=t,this.vapId=i,this.apiClient=e,this.logger=s,this.storageManager=n,this.brandId=a,this.applicationId=r}async init(){this.initialized?this.logger.warn("VisitorConfigManager already initialized"):(this.logger.info("Initializing VisitorConfigManager",{orgId:this.orgId,vapId:this.vapId}),await this.restoreCachedConfig(),this.initialized=!0,this.logger.info(W))}async fetchConfig(){if(!this.initialized)throw new Error("VisitorConfigManager not initialized");if(this.cachedConfig)return this.logger.info(Q),this.cachedConfig;try{this.logger.info("Fetching visitor config from API",{orgId:this.orgId,vapId:this.vapId});const t=await this.apiClient.getVisitorConfig(this.orgId,this.vapId);return t.warnings&&t.warnings.length>0&&t.warnings.forEach(t=>{this.logger.warn("Visitor config warning",{code:t.code,message:t.message})}),this.cachedConfig=t,await this.storeCachedConfig(t),this.logger.info(L,{isEnabled:t.isVisitorTrackingEnabled}),t}catch(t){throw this.logger.error(G,t),new Error(`${y}: ${t}`)}}async isVisitorTrackingEnabled(){try{const t=(await this.fetchConfig()).isVisitorTrackingEnabled;return t?this.logger.info(K):this.logger.info(H),t}catch(t){return this.logger.error("Failed to check visitor tracking status",t),!1}}getCachedConfig(){return this.cachedConfig}async storeCachedConfig(t){try{const i=h("VISITOR_CONFIG",this.brandId,this.applicationId);await this.storageManager.set(i,JSON.stringify(t)),this.logger.debug("Visitor config cached to storage",{key:i})}catch(t){this.logger.warn("Failed to store visitor config to cache",t)}}async restoreCachedConfig(){try{const t=h("VISITOR_CONFIG",this.brandId,this.applicationId),i=await this.storageManager.get(t);if(i){const t=JSON.parse(i);this.cachedConfig=t,this.logger.info("Visitor config restored from cache",{isEnabled:t.isVisitorTrackingEnabled})}}catch(t){this.logger.warn("Failed to restore visitor config from cache",t),this.cachedConfig=null}}async clearCachedConfig(){this.cachedConfig=null;try{const t=h("VISITOR_CONFIG",this.brandId,this.applicationId);await this.storageManager.remove(t),this.logger.debug("Visitor config cache cleared")}catch(t){this.logger.warn("Failed to clear visitor config cache",t)}}async destroy(){this.logger.info("Destroying VisitorConfigManager"),await this.clearCachedConfig(),this.initialized=!1,this.logger.info("VisitorConfigManager destroyed successfully")}}class kt{constructor(t,i,e,s,n,a,r,o){this.initialized=!1,this.visitorId=null,this.accountId=t,this.orgId=i,this.vapId=e,this.apiClient=s,this.logger=n,this.storageManager=a,this.brandId=r,this.applicationId=o}async init(){this.initialized?this.logger.warn("AnonymousVisitorManager already initialized"):(this.logger.info("Initializing AnonymousVisitorManager",{accountId:this.accountId,orgId:this.orgId,vapId:this.vapId}),await this.restoreVisitorId(),this.initialized=!0,this.logger.info(X))}async getOrCreateVisitorId(t,i){if(!this.initialized)throw new Error("AnonymousVisitorManager not initialized");if(this.visitorId)return this.logger.info(Z,{visitorId:this.visitorId}),this.visitorId;if(!this.accountId||""===this.accountId.trim()){const t=new Error("AccountId is required for visitor creation");throw this.logger.error("Visitor creation validation failed",t),t}try{this.logger.info("Creating new visitor ID",{accountId:this.accountId,hasCommChannels:!!t&&t.length>0,hasExtendedFields:!!i});const e=await this.createVisitor(t,i);return this.visitorId=e,await this.storeVisitorId(e),this.logger.info(j,{visitorId:e}),e}catch(t){throw this.logger.error(J,t),t}}async createVisitor(t,i){try{const e={profiles:[{source:ht.WEBPUSH,accountId:this.accountId,...t&&t.length>0&&{commChannels:t}}],...i&&{extendedFields:i}};this.logger.debug("Visitor creation request payload",{request:e});const s=await this.apiClient.createVisitor(this.orgId,this.vapId,e);return this.handleCreateVisitorResponse(s)}catch(t){throw this.handleCreateVisitorError(t),t}}handleCreateVisitorResponse(t){if(t.warnings&&t.warnings.length>0&&t.warnings.forEach(t=>{this.logger.warn("Visitor creation warning",{code:t.code,message:t.message})}),!t.id||""===t.id.trim())throw new Error("Invalid visitor ID received from API");return t.id}handleCreateVisitorError(t){try{const i=t.response?.data||t;i.warnings&&i.warnings.length>0&&i.warnings.forEach(t=>{t.code===ct.ACCOUNT_NOT_EXISTS?this.logger.error("Account does not exist",{code:t.code,message:t.message,accountId:this.accountId}):this.logger.warn("Visitor creation warning",{code:t.code,message:t.message})}),i.errors&&i.errors.length>0&&i.errors.forEach(t=>{t.code===ct.ACCOUNT_ID_NOT_PASSED?this.logger.error("AccountId not passed",{code:t.code,message:t.message}):this.logger.error("Visitor creation error",{code:t.code,message:t.message})})}catch(t){this.logger.warn("Failed to parse visitor creation error",t)}}getVisitorId(){return this.visitorId}hasVisitorId(){return null!==this.visitorId}async storeVisitorId(t){try{const i=h("VISITOR_ID",this.brandId,this.applicationId);await this.storageManager.set(i,t),this.logger.debug("Visitor ID stored to storage",{visitorId:t,key:i})}catch(t){this.logger.warn("Failed to store visitor ID",t)}}async restoreVisitorId(){try{const t=h("VISITOR_ID",this.brandId,this.applicationId),i=await this.storageManager.get(t);i&&(this.visitorId=i,this.logger.info(Y,{visitorId:i}))}catch(t){this.logger.warn("Failed to restore visitor ID from storage",t),this.visitorId=null}}async clearVisitorId(){try{const t=h("VISITOR_ID",this.brandId,this.applicationId);await this.storageManager.remove(t),this.visitorId=null,this.logger.info("Visitor ID cleared from storage")}catch(t){this.logger.warn("Failed to clear visitor ID",t),this.visitorId=null}}async destroy(){this.logger.info("Destroying AnonymousVisitorManager"),this.initialized=!1,this.logger.info("AnonymousVisitorManager destroyed successfully")}}class Nt{constructor(t){this.userContextSet=!1,this.initialized=!1,this.initializationPromise=null,this.isVisitorTrackingEnabled=!1,this.visitorId=null,this.validateRequiredConfig(t),this.config=t,this.logger=new xt(this.shouldEnableLogging(t.debugLevel)),this.sessionId="",this.storageManager=new Dt(this.logger,t.brandId,t.applicationId),this.authManager=new St(t,this.logger,this.storageManager),this.eventTracker=new pt(t,this.authManager,this.storageManager,this.logger);const i=this.authManager.getApiClient();this.visitorConfigManager=new Ct(t.orgId,t.vapId,i,this.logger,this.storageManager,t.brandId,t.applicationId),this.anonymousVisitorManager=new kt(t.accountId,t.orgId,t.vapId,i,this.logger,this.storageManager,t.brandId,t.applicationId)}static instanceWithConfig(t){return new Nt(t)}shouldEnableLogging(t){return!(!t||"NONE"===t)&&["ERROR","WARN","INFO","DEBUG","VERBOSE"].includes(t)}async getOrCreateSessionId(){try{const t=h("SESSION_ID",this.config.brandId,this.config.applicationId),i=await this.storageManager.get(t);if(i)return i;const e=ft();return await this.storageManager.set(t,e),e}catch(t){return this.logger.warn("Failed to get or create session ID",t),ft()}}async restoreUserContext(){try{const t=h("USER_CONTEXT",this.config.brandId,this.config.applicationId),i=await this.storageManager.get(t);if(i){const t=JSON.parse(i),e=t.cuid;await this.eventTracker.setUserContext(this.config.accountId,t.systemDataArgs,e),this.userContextSet=!0,this.logger.info("User context restored from storage",{cuid:e,accountId:this.config.accountId})}}catch(t){this.logger.warn("Failed to restore user context from storage",t)}}async validateAndClearDifferentUserContext(t){try{const i=h("USER_CONTEXT",this.config.brandId,this.config.applicationId),e=await this.storageManager.get(i);if(e){const i=JSON.parse(e);i.cuid&&i.cuid!==t&&(this.logger.info("Different user detected, clearing previous user context",{previousCuid:i.cuid,newCuid:t}),await this.clearUserContext(),this.userContextSet=!1)}}catch(t){this.logger.warn("Error validating different user context",t),await this.clearUserContext(),this.userContextSet=!1}}async storeUserContext(t,i){try{const e={cuid:t,systemDataArgs:i,timestamp:Date.now()},s=h("USER_CONTEXT",this.config.brandId,this.config.applicationId);await this.storageManager.set(s,JSON.stringify(e))}catch(t){this.logger.warn("Failed to store user context",t)}}init(){this.initialized?this.logger.warn("WebSDK already initialized"):this.initializationPromise?this.logger.warn("WebSDK initialization already in progress"):this.initializationPromise=this.initializeAsync().catch(t=>{this.logger.error(v,t),this.initializationPromise=null})}async initializeAsync(){try{if(this.logger.info("Initializing WebSDK",{version:dt,config:this.config}),await this.storageManager.init(),this.sessionId=await this.getOrCreateSessionId(),await this.authManager.init(),await this.initializeVisitorConfig(),await this.eventTracker.init(),await this.authManager.ensureValidNonce(),await this.restoreUserContext(),!this.userContextSet){const t={country:this.config.country,city:this.config.city,country_code:this.config.countryCode};await this.eventTracker.setUserContext(this.config.accountId,t),this.logger.info("Account context set for anonymous user tracking")}this.initialized=!0,this.logger.info(f)}catch(t){throw new Error(`${u}: ${t}`)}}async initializeVisitorConfig(){this.logger.info("Initializing visitor configuration"),await this.visitorConfigManager.init(),this.isVisitorTrackingEnabled=await this.visitorConfigManager.isVisitorTrackingEnabled(),this.isVisitorTrackingEnabled?(this.logger.info(K),await this.anonymousVisitorManager.init(),await this.getOrCreateVisitorId(),this.eventTracker.setVisitorTrackingState(this.visitorId,!0)):(this.logger.info(H),this.eventTracker.setVisitorTrackingState(null,!1));const t=this.visitorConfigManager.getCachedConfig();t&&t.warnings&&t.warnings.length>0&&t.warnings.forEach(t=>{this.logger.warn("Visitor config warning",{code:t.code,message:t.message})})}async getOrCreateVisitorId(){return this.visitorId=await this.anonymousVisitorManager.getOrCreateVisitorId(this.config.commChannels,this.config.extendedFields),this.logger.info("Visitor ID ready",{visitorId:this.visitorId}),this.visitorId}getVisitorId(){return this.visitorId}async setUserContext(t,i){if(!this.initialized)throw new Error("WebSDK must be initialized before setting user context");await this.validateAndClearDifferentUserContext(t),await this.eventTracker.setUserContext(this.config.accountId,i,t),this.userContextSet=!0,await this.storeUserContext(t,i),this.logger.info("User context set and persisted",{cuid:t,accountId:this.config.accountId})}async clearUserContext(){try{const t=h("USER_CONTEXT",this.config.brandId,this.config.applicationId);await this.storageManager.remove(t),this.userContextSet=!1,this.logger.info("User context cleared")}catch(t){this.logger.warn("Failed to clear user context",t),this.userContextSet=!1}}async track(t){if(!this.initialized)throw new Error("WebSDK must be initialized before tracking events");try{await this.eventTracker.track(t)}catch(i){throw this.logger.error(A,{event:t,error:i}),i}}async destroy(){this.logger.info("Destroying WebSDK instance");try{await this.eventTracker.flush(),await this.eventTracker.destroy(),await this.authManager.destroy(),await this.visitorConfigManager.destroy(),await this.anonymousVisitorManager.destroy(),await this.clearUserContext(),await this.storageManager.destroy(),this.initialized=!1,this.logger.info(m)}catch(t){throw this.logger.error(m,t),t}}pushUserSignin(t,i,e,s,n,a){this.pushUserSigninAsync(t,i,e,s,n,a).catch(i=>{this.logger.error(z,{cuid:t,error:i})})}async pushUserSigninAsync(t,i,e,s,n,a){await this.ensureInitialized(),await this.setUserContextIfNeeded(t);const r={cuid:t,...i&&{first_name:i},...e&&{last_name:e},...s&&{email:s},...n&&{phone:n},...a&&{custom_data:a}},o={type:"user",name:nt,timestamp:Date.now(),sessionId:this.sessionId,userId:t,data:r};try{await this.track(o),this.logger.info("User signin event tracked",{cuid:t,firstName:i,lastName:e,email:s})}catch(i){throw this.logger.error(z,{cuid:t,error:i}),i}}pushUserSignup(t,i,e,s,n,a){this.pushUserSignupAsync(t,i,e,s,n,a).catch(i=>{this.logger.error(P,{cuid:t,error:i})})}async pushUserSignupAsync(t,i,e,s,n,a){await this.ensureInitialized(),await this.setUserContextIfNeeded(t);const r={cuid:t,first_name:i,last_name:e,email:s,phone:n,...a&&{custom_data:a}},o={type:"user",name:at,timestamp:Date.now(),sessionId:this.sessionId,userId:t,data:r};try{await this.track(o),this.logger.info("User signup event tracked",{cuid:t,firstName:i,lastName:e,email:s})}catch(i){throw this.logger.error(P,{cuid:t,error:i}),i}}pushUserUpdate(t,i,e,s,n,a){this.pushUserUpdateAsync(t,i,e,s,n,a).catch(i=>{this.logger.error($,{cuid:t,error:i})})}async pushUserUpdateAsync(t,i,e,s,n,a){await this.ensureInitialized(),await this.setUserContextIfNeeded(t);const r={cuid:t,...i&&{first_name:i},...e&&{last_name:e},...s&&{email:s},...n&&{phone:n},...a&&{custom_data:a}},o={type:"user",name:rt,timestamp:Date.now(),sessionId:this.sessionId,userId:t,data:r};try{await this.track(o),this.logger.info("User update event tracked",{cuid:t,firstName:i,lastName:e,email:s})}catch(i){throw this.logger.error($,{cuid:t,error:i}),i}}pushUserSignOut(t){this.pushUserSignOutAsync(t).catch(i=>{this.logger.error(B,{cuid:t,error:i})})}async pushUserSignOutAsync(t){await this.ensureInitialized(),await this.setUserContextIfNeeded(t);const i={type:"user",name:ot,timestamp:Date.now(),sessionId:this.sessionId,userId:t,data:{cuid:t}};try{await this.track(i),this.logger.info("User signout event tracked",{cuid:t})}catch(i){this.logger.warn("Failed to track signout event (tracking may be disabled)",{cuid:t,error:i})}try{if(await this.clearUserContext(),this.logger.info("User context cleared, returning to anonymous mode"),this.isVisitorTrackingEnabled)try{await this.anonymousVisitorManager.clearVisitorId(),this.logger.info("Visitor ID cleared on user signout"),this.visitorId=await this.anonymousVisitorManager.getOrCreateVisitorId(this.config.commChannels,this.config.extendedFields),this.logger.info("New anonymous visitor ID generated after signout",{visitorId:this.visitorId}),this.eventTracker.setVisitorTrackingState(this.visitorId,!0)}catch(t){this.logger.warn("Failed to regenerate visitor ID on signout",t),this.visitorId=null,this.eventTracker.setVisitorTrackingState(null,!0)}this.logger.info("SDK remains active for anonymous tracking")}catch(t){throw this.logger.error("Failed to clear user context on signout",t),t}}pushEvent(t,i){this.pushEventAsync(t,i).catch(i=>{this.logger.error(q,{eventName:t,error:i})})}async pushEventAsync(t,i){if(await this.ensureInitialized(),!this.isVisitorTrackingEnabled)return void this.logger.warn("Event tracking skipped: Visitor tracking is disabled",{eventName:t});if(!this.userContextSet&&!this.visitorId)return void this.logger.warn("Event tracking skipped: No visitor ID available and no user context set",{eventName:t});const e={event_name:t,...i&&i},s={type:"behavioral",name:t,timestamp:Date.now(),sessionId:this.sessionId,data:e};try{await this.track(s),this.logger.info("Behavioral event tracked",{eventName:t,attributes:i})}catch(i){throw this.logger.error(q,{eventName:t,error:i}),i}}validateRequiredConfig(t){const i=[];if(t.accountId||i.push("accountId"),t.baseURL||i.push("baseURL"),t.orgId||i.push("orgId"),i.length>0)throw new Error(`WebSDK initialization failed: Missing required configuration fields: ${i.join(", ")}`)}async ensureInitialized(){if(this.initializationPromise)try{await this.initializationPromise}catch(t){throw new Error(`SDK initialization failed: ${t}`)}if(!this.initialized)throw new Error("WebSDK must be initialized before tracking events. Call init() first.")}async setUserContextIfNeeded(t){if(!this.userContextSet){const i={country:this.config.country,city:this.config.city,country_code:this.config.countryCode};await this.setUserContext(t,i),this.logger.debug("User context set automatically",{cuid:t,systemDataArgs:i})}}}return Nt});
